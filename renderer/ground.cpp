/* Copyright (c) 2017 Hans-Kristian Arntzen
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "ground.hpp"
#include "device.hpp"
#include "render_context.hpp"
#include "renderer.hpp"

using namespace Vulkan;
using namespace std;
using namespace Util;

namespace Granite {

struct PatchInstanceInfo {
  vec4 lods;
  vec2 offsets;
  float inner_lod;
};

struct PatchInfo {
  Program* program;

  const Vulkan::Buffer* vbo;
  const Vulkan::Buffer* ibo;
  unsigned count;

  const Vulkan::ImageView* heights;
  const Vulkan::ImageView* normals;
  const Vulkan::ImageView* occlusion;
  const Vulkan::ImageView* normals_fine;
  const Vulkan::ImageView* base_color;
  const Vulkan::ImageView* lod_map;
  const Vulkan::ImageView* type_map;

  mat4 push[2];

  vec2 inv_heightmap_size;
  vec2 tiling_factor;
  vec2 tangent_scale;
};

struct GroundVertex {
  uint8_t pos[4];
  uint8_t weights[4];
};

struct GroundData {
  vec2 inv_heightmap_size;
  vec2 uv_shift;
  vec2 uv_tiling_scale;
  vec2 tangent_scale;
};

struct PatchData {
  vec2 Offset;
  float InnerLOD;
  float Padding;
  vec4 LODs;
};

namespace RenderFunctions {
static void ground_patch_render(Vulkan::CommandBuffer& cmd,
                                const RenderQueueData* infos,
                                unsigned instances) {
  auto& patch = *static_cast<const PatchInfo*>(infos->render_info);

  cmd.set_program(*patch.program);
  cmd.set_primitive_topology(VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP);
  // cmd.set_wireframe(true);
  cmd.set_primitive_restart(true);

  cmd.set_index_buffer(*patch.ibo, 0, VK_INDEX_TYPE_UINT16);
  cmd.set_vertex_binding(0, *patch.vbo, 0, sizeof(GroundVertex),
                         VK_VERTEX_INPUT_RATE_VERTEX);
  cmd.set_vertex_attrib(0, 0, VK_FORMAT_R8G8B8A8_UINT,
                        offsetof(GroundVertex, pos));
  cmd.set_vertex_attrib(1, 0, VK_FORMAT_R8G8B8A8_UNORM,
                        offsetof(GroundVertex, weights));

  cmd.set_texture(
      2, 0, *patch.heights,
      cmd.get_device().get_stock_sampler(StockSampler::LinearClamp));
  cmd.set_texture(
      2, 1, *patch.normals,
      cmd.get_device().get_stock_sampler(StockSampler::TrilinearClamp));
  cmd.set_texture(
      2, 2, *patch.occlusion,
      cmd.get_device().get_stock_sampler(StockSampler::LinearClamp));
  cmd.set_texture(
      2, 3, *patch.lod_map,
      cmd.get_device().get_stock_sampler(StockSampler::LinearClamp));
  cmd.set_texture(
      2, 4, *patch.base_color,
      cmd.get_device().get_stock_sampler(StockSampler::TrilinearWrap));
  cmd.set_texture(
      2, 5, *patch.type_map,
      cmd.get_device().get_stock_sampler(StockSampler::LinearClamp));
  cmd.set_texture(
      2, 6, *patch.normals_fine,
      cmd.get_device().get_stock_sampler(StockSampler::TrilinearWrap));

  auto* data = static_cast<GroundData*>(
      cmd.allocate_constant_data(3, 1, sizeof(GroundData)));
  data->inv_heightmap_size = patch.inv_heightmap_size;
  data->uv_shift = vec2(0.0f);
  data->uv_tiling_scale = patch.tiling_factor;
  data->tangent_scale = patch.tangent_scale;

  cmd.push_constants(patch.push, 0, sizeof(patch.push));

  for (unsigned i = 0; i < instances; i += 512) {
    unsigned to_render = std::min(instances - i, 512u);

    auto* patches = static_cast<PatchData*>(
        cmd.allocate_constant_data(3, 0, sizeof(PatchData) * to_render));
    for (unsigned j = 0; j < to_render; j++) {
      auto& patch =
          *static_cast<const PatchInstanceInfo*>(infos[i + j].instance_data);
      patches->LODs = patch.lods;
      patches->InnerLOD = patch.inner_lod;
      patches->Offset = patch.offsets;
      patches++;
    }

    cmd.draw_indexed(patch.count, to_render);
  }
}
}  // namespace RenderFunctions

void GroundPatch::set_bounds(vec3 offset, vec3 size) {
  this->offset = offset.xz();
  this->size = size.xz();
  aabb = AABB(offset, offset + size);
}

GroundPatch::GroundPatch(Util::IntrusivePtr<Ground> ground) : ground(ground) {}

void GroundPatch::refresh(RenderContext& context,
                          const CachedSpatialTransformComponent* transform) {
  vec3 center = transform->world_aabb.get_center();
  const auto& camera_pos = context.get_render_parameters().camera_position;
  vec3 diff = center - camera_pos;
  float dist_log2 = 0.5f * glm::log2(dot(diff, diff) + 0.001f);
  *lod = clamp(dist_log2 + lod_bias + ground->get_base_lod_bias(), 0.0f,
               ground->get_info().max_lod);
}

void GroundPatch::get_render_info(
    const RenderContext& context,
    const CachedSpatialTransformComponent* transform,
    RenderQueue& queue) const {
  ground->get_render_info(context, transform, queue, *this);
}

Ground::Ground(unsigned size, const TerrainInfo& info)
    : size(size), info(info) {
  assert(size % info.base_patch_size == 0);
  num_patches_x = size / info.base_patch_size;
  num_patches_z = size / info.base_patch_size;
  patch_lods.resize(num_patches_x * num_patches_z);

  EVENT_MANAGER_REGISTER_LATCH(Ground, on_device_created, on_device_destroyed,
                               DeviceCreatedEvent);
}

void Ground::on_device_created(const DeviceCreatedEvent& created) {
  auto& device = created.get_device();
  heights = device.get_texture_manager().request_texture(info.heightmap);
  normals = device.get_texture_manager().request_texture(info.normalmap);
  occlusion = device.get_texture_manager().request_texture(info.occlusionmap);
  normals_fine =
      device.get_texture_manager().request_texture(info.normalmap_fine);
  base_color = device.get_texture_manager().request_texture(info.base_color);
  type_map = device.get_texture_manager().request_texture(info.splatmap);
  build_buffers(device);

  ImageCreateInfo info = {};
  info.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;
  info.domain = ImageDomain::Physical;
  info.width = num_patches_x;
  info.height = num_patches_z;
  info.levels = 1;
  info.format = VK_FORMAT_R16_SFLOAT;
  info.type = VK_IMAGE_TYPE_2D;
  info.depth = 1;
  info.samples = VK_SAMPLE_COUNT_1_BIT;
  info.initial_layout = VK_IMAGE_LAYOUT_UNDEFINED;
  lod_map = device.create_image(info, nullptr);
}

void Ground::build_lod(Device& device, unsigned size, unsigned stride) {
  unsigned size_1 = size + 1;
  vector<GroundVertex> vertices;
  vertices.reserve(size_1 * size_1);
  vector<uint16_t> indices;
  indices.reserve(size * (2 * size_1 + 1));

  unsigned half_size = info.base_patch_size >> 1;

  for (unsigned y = 0; y <= info.base_patch_size; y += stride) {
    for (unsigned x = 0; x <= info.base_patch_size; x += stride) {
      GroundVertex v = {};
      v.pos[0] = uint8_t(x);
      v.pos[1] = uint8_t(y);
      v.pos[2] = uint8_t(x < half_size);
      v.pos[3] = uint8_t(y < half_size);

      if (x == 0)
        v.weights[0] = 255;
      else if (x == info.base_patch_size)
        v.weights[1] = 255;
      else if (y == 0)
        v.weights[2] = 255;
      else if (y == info.base_patch_size)
        v.weights[3] = 255;

      vertices.push_back(v);
    }
  }

  unsigned slices = size;
  for (unsigned slice = 0; slice < slices; slice++) {
    unsigned base = slice * size_1;
    for (unsigned x = 0; x <= size; x++) {
      indices.push_back(base + x);
      indices.push_back(base + size_1 + x);
    }
    indices.push_back(0xffffu);
  }

  BufferCreateInfo info = {};
  info.size = vertices.size() * sizeof(GroundVertex);
  info.domain = BufferDomain::Device;
  info.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;

  LOD lod;
  lod.vbo = device.create_buffer(info, vertices.data());

  info.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
  info.size = indices.size() * sizeof(uint16_t);
  lod.ibo = device.create_buffer(info, indices.data());
  lod.count = indices.size();

  quad_lod.push_back(lod);
}

void Ground::build_buffers(Device& device) {
  unsigned size = info.base_patch_size;
  unsigned stride = 1;
  while (size >= 2) {
    build_lod(device, size, stride);
    size >>= 1;
    stride <<= 1;
  }
}

void Ground::on_device_destroyed(const DeviceCreatedEvent&) {
  heights = nullptr;
  normals = nullptr;
  occlusion = nullptr;
  normals_fine = nullptr;
  base_color = nullptr;
  type_map = nullptr;
  quad_lod.clear();
  lod_map.reset();
}

void Ground::get_render_info(const RenderContext& context,
                             const CachedSpatialTransformComponent* transform,
                             RenderQueue& queue,
                             const GroundPatch& ground_patch) const {
  PatchInfo patch;
  patch.push[0] = transform->transform->world_transform;

  // The normalmaps are generated with the reference that neighbor pixels are
  // certain length apart. However, the base mesh [0, normal_size) is squashed
  // to [0, 1] size in X/Z direction. We compensate for this scaling by doing
  // the inverse transposed normal matrix properly here.
  patch.push[1] = transform->transform->normal_transform *
                  glm::scale(vec3(info.normal_size, 1.0f, info.normal_size));

  // Find something concrete to put here.
  patch.tangent_scale = vec2(1.0f / 10.0f);

  auto* instance_data = queue.allocate_one<PatchInstanceInfo>();
  instance_data->lods = vec4(*ground_patch.nx->lod, *ground_patch.px->lod,
                             *ground_patch.nz->lod, *ground_patch.pz->lod);
  instance_data->inner_lod = *ground_patch.lod;
  instance_data->lods =
      max(vec4(instance_data->inner_lod), instance_data->lods);
  instance_data->offsets = ground_patch.offset * vec2(size);

  int base_lod = int(instance_data->inner_lod);
  patch.vbo = quad_lod[base_lod].vbo.get();
  patch.ibo = quad_lod[base_lod].ibo.get();
  patch.count = quad_lod[base_lod].count;

  auto heightmap = heights->get_image();
  auto normal = normals->get_image();
  auto occlusionmap = occlusion->get_image();
  auto normal_fine = normals_fine->get_image();
  auto base_color_image = base_color->get_image();
  auto splatmap_image = type_map->get_image();
  patch.heights = &heightmap->get_view();
  patch.normals = &normal->get_view();
  patch.occlusion = &occlusionmap->get_view();
  patch.normals_fine = &normal_fine->get_view();
  patch.base_color = &base_color_image->get_view();
  patch.lod_map = &lod_map->get_view();
  patch.type_map = &splatmap_image->get_view();
  patch.inv_heightmap_size = vec2(1.0f / size);
  patch.tiling_factor = tiling_factor;

  Util::Hasher hasher;
  hasher.string("ground");
  auto pipe_hash = hasher.get();
  hasher.s32(base_lod);
  auto sorting_key = RenderInfo::get_sort_key(
      context, Queue::Opaque, pipe_hash, hasher.get(),
      transform->world_aabb.get_center(), StaticLayer::Last);

  hasher.u64(heightmap->get_cookie());
  hasher.u64(normal->get_cookie());
  hasher.u64(normal_fine->get_cookie());
  hasher.u64(occlusionmap->get_cookie());
  hasher.u64(base_color_image->get_cookie());
  hasher.u64(splatmap_image->get_cookie());
  hasher.u64(lod_map->get_cookie());

  // Allow promotion to push constant for transforms.
  // We'll instance a lot of patches belonging to the same ground.
  hasher.pointer(transform->transform);

  auto instance_key = hasher.get();

  auto* patch_data = queue.push<PatchInfo>(
      Queue::Opaque, instance_key, sorting_key,
      RenderFunctions::ground_patch_render, instance_data);

  if (patch_data) {
    patch.program =
        queue.get_shader_suites()[ecast(RenderableType::Ground)]
            .get_program(DrawPipeline::Opaque, MESH_ATTRIBUTE_POSITION_BIT,
                         MATERIAL_TEXTURE_BASE_COLOR_BIT)
            .get();

    *patch_data = patch;
  }
}

void Ground::refresh(RenderContext& context) {
  auto& device = context.get_device();
  auto cmd = device.request_command_buffer();

  cmd->image_barrier(
      *lod_map, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
      VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_TRANSFER_BIT, 0,
      VK_PIPELINE_STAGE_TRANSFER_BIT, VK_ACCESS_TRANSFER_WRITE_BIT);
  lod_map->set_layout(VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
  uint16_t* data = static_cast<uint16_t*>(cmd->update_image(*lod_map));

  const auto quantize = [](float v) -> uint16_t { return packHalf1x16(v); };

  for (auto lod : patch_lods)
    *data++ = quantize(lod);

  cmd->image_barrier(
      *lod_map, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
      VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_PIPELINE_STAGE_TRANSFER_BIT,
      VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
      VK_ACCESS_SHADER_READ_BIT);
  lod_map->set_layout(VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
  device.submit(cmd);
}

Ground::Handles Ground::add_to_scene(Scene& scene,
                                     unsigned size,
                                     float tiling_factor,
                                     const TerrainInfo& info) {
  Handles handles;

  handles.node = scene.create_node();
  handles.entity = scene.create_entity();

  auto ground = make_handle<Ground>(size, info);
  ground->set_tiling_factor(vec2(tiling_factor));

  auto* ground_component =
      handles.entity->allocate_component<GroundComponent>();
  ground_component->ground = ground.get();

  auto* update_component =
      handles.entity->allocate_component<PerFrameUpdateComponent>();
  update_component->refresh = ground.get();

  auto* cached_transform =
      handles.entity->allocate_component<CachedSpatialTransformComponent>();
  cached_transform->transform = &handles.node->cached_transform;
  cached_transform->skin_transform = nullptr;

  handles.ground = ground.get();

  vec2 inv_patches = vec2(1.0f / ground->get_num_patches_x(),
                          1.0f / ground->get_num_patches_z());

  vector<GroundPatch*> patches;
  patches.reserve(ground->get_num_patches_x() * ground->get_num_patches_z());

  if (!info.patch_lod_bias.empty() &&
      info.patch_lod_bias.size() !=
          (ground->get_num_patches_x() * ground->get_num_patches_z()))
    throw logic_error("Mismatch in number of patch lod biases and patches.");

  const float* patch_bias =
      info.patch_lod_bias.empty() ? nullptr : info.patch_lod_bias.data();
  const vec2* patch_range =
      info.patch_range.empty() ? nullptr : info.patch_range.data();

  for (unsigned z = 0; z < ground->get_num_patches_z(); z++) {
    for (unsigned x = 0; x < ground->get_num_patches_x(); x++) {
      auto patch =
          make_abstract_handle<AbstractRenderable, GroundPatch>(ground);
      auto* p = static_cast<GroundPatch*>(patch.get());

      float min_y = -1.0f;
      float max_y = 1.0f;
      if (patch_range) {
        min_y = patch_range->x;
        max_y = patch_range->y;
        patch_range++;
      }

      p->set_bounds(vec3(x * inv_patches.x, min_y - 0.01f, z * inv_patches.y),
                    vec3(inv_patches.x, max_y - min_y + 0.02f, inv_patches.y));

      p->set_lod_pointer(ground->get_lod_pointer(x, z));
      auto patch_entity = scene.create_renderable(patch, handles.node.get());

      // TODO: Warpy patches shouldn't cast static shadow.
      patch_entity->free_component<CastsStaticShadowComponent>();

      auto* transforms =
          patch_entity->allocate_component<PerFrameUpdateTransformComponent>();
      transforms->refresh = p;

      if (patch_bias) {
        p->lod_bias = *patch_bias;
        patch_bias++;
      }

      patches.push_back(p);
    }
  }

  int num_x = int(ground->get_num_patches_x());
  int num_z = int(ground->get_num_patches_z());

  // Set up neighbors.
  for (int z = 0; z < num_z; z++) {
    for (int x = 0; x < num_x; x++) {
      auto* nx = patches[z * num_x + glm::max(x - 1, 0)];
      auto* px = patches[z * num_x + glm::min(x + 1, num_x - 1)];
      auto* nz = patches[glm::max(z - 1, 0) * num_x + x];
      auto* pz = patches[glm::min(z + 1, num_z - 1) * num_x + x];
      patches[z * num_x + x]->set_neighbors(nx, px, nz, pz);
    }
  }

  return handles;
}
}  // namespace Granite
